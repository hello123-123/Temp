import java.util.*;

class State {
    int jugA;
    int jugB;
    int cost; // Total cost (g(n) + h(n))

    public State(int jugA, int jugB, int cost) {
        this.jugA = jugA;
        this.jugB = jugB;
        this.cost = cost;
    }

    @Override
    public int hashCode() {
        return 31 * jugA + jugB;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        State state = (State) obj;
        return jugA == state.jugA && jugB == state.jugB;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter the capacity of jug 1: ");
        int jugACapacity = scanner.nextInt();
        System.out.print("Enter the capacity of jug 2: ");
        int jugBCapacity = scanner.nextInt();
        System.out.print("Enter the target amount of water: ");
        int targetAmount = scanner.nextInt();
        scanner.close();

        solveWaterJugProblem(jugACapacity, jugBCapacity, targetAmount);
    }

    private static void solveWaterJugProblem(int jugACapacity, int jugBCapacity, int targetAmount) {
        PriorityQueue<State> priorityQueue = new PriorityQueue<>(Comparator.comparingInt(state -> state.cost));
        Set<State> visited = new HashSet<>();

        State initialState = new State(0, 0, 0);
        priorityQueue.offer(initialState);
        visited.add(initialState);

        while (!priorityQueue.isEmpty()) {
            State currentState = priorityQueue.poll();

            // Check if the target amount is reached
            if (currentState.jugA == targetAmount || currentState.jugB == targetAmount) {
                System.out.println("Solution found: (" + currentState.jugA + ", " + currentState.jugB + ")");
                return;
            }

            // Explore all possible moves (pouring water from one jug to another)
            exploreMove(priorityQueue, visited, new State(jugACapacity, currentState.jugB, currentState.cost + 1), currentState);
            exploreMove(priorityQueue, visited, new State(currentState.jugA, jugBCapacity, currentState.cost + 1), currentState);
            exploreMove(priorityQueue, visited, new State(0, currentState.jugB, currentState.cost + 1), currentState);
            exploreMove(priorityQueue, visited, new State(currentState.jugA, 0, currentState.cost + 1), currentState);
            exploreMove(priorityQueue, visited, new State(Math.min(jugACapacity, currentState.jugA + currentState.jugB),
                    currentState.jugB - Math.min(jugACapacity - currentState.jugA, currentState.jugB), currentState.cost + 1), currentState);
            exploreMove(priorityQueue, visited, new State(currentState.jugA - Math.min(jugBCapacity - currentState.jugB, currentState.jugA),
                    Math.min(jugBCapacity, currentState.jugA + currentState.jugB), currentState.cost + 1), currentState);
        }

        System.out.println("Solution not found.");
    }

    private static void exploreMove(PriorityQueue<State> priorityQueue, Set<State> visited, State nextState, State currentState) {
        if (!visited.contains(nextState)) {
            priorityQueue.offer(nextState);
            visited.add(nextState);
            // Print the state transition
            System.out.println("(" + currentState.jugA + ", " + currentState.jugB + ") -> (" + nextState.jugA + ", " + nextState.jugB + ")");
        }
    }
}
